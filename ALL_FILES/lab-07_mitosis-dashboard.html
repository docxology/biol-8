<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lab 7 Dashboard: Mitosis | BIOL-8</title>
<style>
/* ═══════════════════════════════════════════════════════════════════════
   RESET & BASE
   ═══════════════════════════════════════════════════════════════════════ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #f0f2f5; --card: #ffffff; --sidebar: #1a1a2e; --sidebar-hover: #252545;
  --accent: #c41e3a; --accent-light: #e8354f; --blue: #2563eb; --blue-light: #3b82f6;
  --green: #16a34a; --amber: #d97706; --purple: #7c3aed;
  --text: #1a1a1a; --text-muted: #6b7280; --border: #e5e7eb;
  --radius: 10px; --shadow: 0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06);
  --shadow-lg: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -4px rgba(0,0,0,0.1);
  --font: 'Segoe UI', system-ui, -apple-system, sans-serif;
  --mono: 'SF Mono', 'Cascadia Code', 'Consolas', monospace;
}
html { scroll-behavior: smooth; }
body { font-family: var(--font); background: var(--bg); color: var(--text); line-height: 1.6; }

/* ═══════════════════════════════════════════════════════════════════════
   LAYOUT
   ═══════════════════════════════════════════════════════════════════════ */
.layout { display: flex; min-height: 100vh; }
.sidebar {
  width: 260px; background: var(--sidebar); color: #e2e8f0; position: fixed;
  top: 0; left: 0; height: 100vh; overflow-y: auto; z-index: 100;
  display: flex; flex-direction: column;
}
.sidebar-header { padding: 24px 20px 16px; border-bottom: 1px solid rgba(255,255,255,0.1); }
.sidebar-header h1 { font-size: 15px; font-weight: 700; color: #fff; letter-spacing: 0.5px; }
.sidebar-header p { font-size: 12px; color: #94a3b8; margin-top: 4px; }
.sidebar-nav { flex: 1; padding: 12px 0; }
.sidebar-nav a {
  display: flex; align-items: center; gap: 10px; padding: 10px 20px;
  color: #94a3b8; text-decoration: none; font-size: 13px; font-weight: 500;
  transition: all 0.15s; border-left: 3px solid transparent;
}
.sidebar-nav a:hover { background: var(--sidebar-hover); color: #e2e8f0; }
.sidebar-nav a.active { color: #fff; background: var(--sidebar-hover); border-left-color: var(--accent); }
.sidebar-nav .nav-num {
  display: inline-flex; align-items: center; justify-content: center;
  width: 22px; height: 22px; border-radius: 6px; font-size: 11px; font-weight: 700;
  background: rgba(255,255,255,0.08); flex-shrink: 0;
}
.sidebar-nav a.active .nav-num { background: var(--accent); color: #fff; }
.sidebar-footer { padding: 16px 20px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 11px; color: #64748b; }

.main { margin-left: 260px; flex: 1; padding: 32px; max-width: 1200px; }

/* ═══════════════════════════════════════════════════════════════════════
   CARDS & SECTIONS
   ═══════════════════════════════════════════════════════════════════════ */
.section { margin-bottom: 40px; scroll-margin-top: 24px; }
.section-header {
  display: flex; align-items: center; gap: 12px; margin-bottom: 20px;
}
.section-num {
  display: flex; align-items: center; justify-content: center;
  width: 36px; height: 36px; border-radius: 10px;
  background: var(--accent); color: #fff; font-weight: 800; font-size: 16px; flex-shrink: 0;
}
.section-title { font-size: 22px; font-weight: 700; }
.section-subtitle { font-size: 13px; color: var(--text-muted); margin-top: 2px; }

.card {
  background: var(--card); border-radius: var(--radius); box-shadow: var(--shadow);
  padding: 24px; margin-bottom: 16px; border: 1px solid var(--border);
}
.card-title { font-size: 15px; font-weight: 700; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
.card-row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
.card-row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; }
@media (max-width: 900px) { .card-row, .card-row-3 { grid-template-columns: 1fr; } }

/* ═══════════════════════════════════════════════════════════════════════
   BUTTONS & INPUTS
   ═══════════════════════════════════════════════════════════════════════ */
.btn {
  display: inline-flex; align-items: center; justify-content: center; gap: 6px;
  padding: 10px 20px; border-radius: 8px; font-size: 14px; font-weight: 600;
  border: none; cursor: pointer; transition: all 0.15s; font-family: var(--font);
}
.btn-primary { background: var(--accent); color: #fff; }
.btn-primary:hover { background: var(--accent-light); transform: translateY(-1px); box-shadow: var(--shadow-lg); }
.btn-secondary { background: var(--blue); color: #fff; }
.btn-secondary:hover { background: var(--blue-light); }
.btn-outline { background: transparent; color: var(--text); border: 2px solid var(--border); }
.btn-outline:hover { border-color: var(--accent); color: var(--accent); }
.btn-sm { padding: 6px 14px; font-size: 12px; }
.btn-group { display: flex; gap: 8px; flex-wrap: wrap; margin: 12px 0; }

.slider-group { display: flex; align-items: center; gap: 12px; margin: 8px 0; }
.slider-group label { font-size: 13px; font-weight: 600; min-width: 80px; }
.slider-group input[type=range] { flex: 1; accent-color: var(--accent); }
.slider-val { font-family: var(--mono); font-size: 14px; font-weight: 700; min-width: 50px; text-align: right; }

/* ═══════════════════════════════════════════════════════════════════════
   STATS & BADGES
   ═══════════════════════════════════════════════════════════════════════ */
.stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; margin: 12px 0; }
.stat-box {
  text-align: center; padding: 14px 8px; border-radius: 8px;
  background: #f8fafc; border: 1px solid var(--border);
}
.stat-box .stat-val { font-size: 28px; font-weight: 800; font-family: var(--mono); }
.stat-box .stat-label { font-size: 11px; color: var(--text-muted); margin-top: 2px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
.stat-accent .stat-val { color: var(--accent); }
.stat-blue .stat-val { color: var(--blue); }
.stat-green .stat-val { color: var(--green); }
.stat-amber .stat-val { color: var(--amber); }
.stat-purple .stat-val { color: var(--purple); }

.badge {
  display: inline-block; padding: 2px 10px; border-radius: 20px;
  font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px;
}
.badge-red { background: #fef2f2; color: var(--accent); }
.badge-blue { background: #eff6ff; color: var(--blue); }
.badge-green { background: #f0fdf4; color: var(--green); }

/* ═══════════════════════════════════════════════════════════════════════
   CHART CONTAINERS
   ═══════════════════════════════════════════════════════════════════════ */
.chart-wrap { position: relative; width: 100%; margin: 8px 0; }
.chart-wrap canvas { width: 100% !important; display: block; border-radius: 6px; }

/* ═══════════════════════════════════════════════════════════════════════
   DATA GRID
   ═══════════════════════════════════════════════════════════════════════ */
.data-grid {
  display: grid; gap: 3px; margin: 10px 0; font-family: var(--mono); font-size: 14px;
}
.data-grid .cell {
  display: flex; align-items: center; justify-content: center;
  height: 38px; border-radius: 4px; font-weight: 700; transition: all 0.2s;
}
.data-grid .cell-header { background: #1a1a1a; color: #fff; font-size: 11px; font-weight: 600; }
.data-grid .cell-label { background: #f1f5f9; color: var(--text); font-size: 12px; font-weight: 600; }
.data-grid .cell-empty { background: #fafafa; border: 1px dashed #d1d5db; color: #d1d5db; }
.data-grid .cell-new { animation: cellPop 0.3s ease; }
@keyframes cellPop { 0% { transform: scale(0.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }

/* ═══════════════════════════════════════════════════════════════════════
   ANALYSIS PANEL
   ═══════════════════════════════════════════════════════════════════════ */
.analysis-result {
  background: #f8fafc; border-radius: 8px; padding: 16px; margin: 10px 0;
  border-left: 4px solid var(--blue); font-size: 14px;
}
.analysis-result .ar-title { font-weight: 700; margin-bottom: 6px; }
.analysis-result code { font-family: var(--mono); background: #e2e8f0; padding: 1px 6px; border-radius: 4px; font-size: 13px; }
.analysis-result.ar-pass { border-left-color: var(--green); }
.analysis-result.ar-fail { border-left-color: var(--accent); }

/* ═══════════════════════════════════════════════════════════════════════
   HERO BANNER
   ═══════════════════════════════════════════════════════════════════════ */
.hero {
  background: linear-gradient(135deg, #1a1a2e 0%, #2d1b3d 50%, #3b1a2e 100%);
  color: #fff; border-radius: var(--radius); padding: 36px; margin-bottom: 32px;
  position: relative; overflow: hidden;
}
.hero::after {
  content: ''; position: absolute; top: -50%; right: -20%; width: 500px; height: 500px;
  background: radial-gradient(circle, rgba(196,30,58,0.15) 0%, transparent 70%);
  pointer-events: none;
}
.hero h2 { font-size: 28px; font-weight: 800; margin-bottom: 8px; }
.hero p { font-size: 15px; color: #cbd5e1; max-width: 600px; line-height: 1.7; }
.hero .bio-tags { display: flex; gap: 8px; margin-top: 16px; flex-wrap: wrap; }
.hero .bio-tag {
  padding: 4px 14px; border-radius: 20px; font-size: 12px; font-weight: 600;
  background: rgba(255,255,255,0.1); backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,0.15);
}

/* ═══════════════════════════════════════════════════════════════════════
   CONVERGENCE LINE
   ═══════════════════════════════════════════════════════════════════════ */
.convergence-info { display: flex; gap: 20px; align-items: center; flex-wrap: wrap; margin: 10px 0; font-size: 13px; }
.convergence-info .ci-dot { width: 12px; height: 3px; border-radius: 2px; display: inline-block; }

/* ═══════════════════════════════════════════════════════════════════════
   PHASE COLORS (mitosis-specific)
   ═══════════════════════════════════════════════════════════════════════ */
.phase-interphase { color: #6366f1; }
.phase-prophase { color: #dc2626; }
.phase-metaphase { color: #ea580c; }
.phase-anaphase { color: #16a34a; }
.phase-telophase { color: #2563eb; }
.phase-cytokinesis { color: #7c3aed; }

.phase-btn { padding: 8px 16px; border-radius: 8px; font-size: 13px; font-weight: 600; border: 2px solid var(--border); background: #fff; cursor: pointer; transition: all 0.15s; }
.phase-btn:hover { border-color: var(--accent); }
.phase-btn.active { border-color: var(--accent); background: #fef2f2; color: var(--accent); }

.toggle-group { display: flex; gap: 6px; flex-wrap: wrap; margin: 10px 0; }
.toggle-btn { padding: 6px 14px; border-radius: 20px; font-size: 12px; font-weight: 600; border: 1px solid var(--border); background: #fff; cursor: pointer; transition: all 0.15s; }
.toggle-btn:hover { border-color: var(--accent); }
.toggle-btn.active { background: var(--accent); color: #fff; border-color: var(--accent); }

/* ═══════════════════════════════════════════════════════════════════════
   RESPONSIVE
   ═══════════════════════════════════════════════════════════════════════ */
@media (max-width: 768px) {
  .sidebar { display: none; }
  .main { margin-left: 0; padding: 16px; }
}
</style>
</head>
<body>
<div class="layout">

<!-- ═══════════════════════════════════════════════════════════════════════
     SIDEBAR
     ═══════════════════════════════════════════════════════════════════════ -->
<aside class="sidebar">
  <div class="sidebar-header">
    <h1>BIOL-8: Human Biology</h1>
    <p>Lab 7 &mdash; Mitosis</p>
  </div>
  <nav class="sidebar-nav">
    <a href="#hero" class="active"><span class="nav-num">&bull;</span> Overview</a>
    <a href="#part1"><span class="nav-num">1</span> Phase Animator</a>
    <a href="#part2"><span class="nav-num">2</span> Virtual Microscope</a>
    <a href="#part3"><span class="nav-num">3</span> Cell Cycle Clock</a>
    <a href="#part4"><span class="nav-num">4</span> Cancer &amp; Control</a>
    <a href="#part5"><span class="nav-num">5</span> Wound Healing</a>
    <a href="#part6"><span class="nav-num">6</span> Chromosome Challenge</a>
  </nav>
  <div class="sidebar-footer">Interactive Lab Dashboard<br>&copy; 2026 BIOL-8</div>
</aside>

<!-- ═══════════════════════════════════════════════════════════════════════
     MAIN CONTENT
     ═══════════════════════════════════════════════════════════════════════ -->
<div class="main">

<!-- HERO -->
<div class="hero" id="hero">
  <h2>Mitosis</h2>
  <p>Explore the stages of cell division in human cells. Classify cells under a virtual microscope, calculate mitotic index, investigate cell cycle control, and see how mitosis powers wound healing.</p>
  <div class="bio-tags">
    <span class="bio-tag">Cell Division</span>
    <span class="bio-tag">Cell Cycle</span>
    <span class="bio-tag">Growth &amp; Repair</span>
  </div>
</div>

<!-- ═══════════════════════ PART 1: MITOSIS PHASE ANIMATOR ════════════ -->
<div class="section" id="part1">
  <div class="section-header">
    <div class="section-num">1</div>
    <div><div class="section-title">Mitosis Phase Animator</div>
    <div class="section-subtitle">Step through each phase of mitosis in a human cell (2n=4 simplified for visibility)</div></div>
  </div>
  <div class="card">
    <div class="card-title">Cell Division Animation</div>
    <div class="chart-wrap"><canvas id="phase-canvas" height="380"></canvas></div>
    <div class="btn-group">
      <button class="btn btn-outline btn-sm" onclick="phaseStep(-1)">&larr; Previous</button>
      <button class="btn btn-primary" id="phase-play-btn" onclick="phaseTogglePlay()">Play</button>
      <button class="btn btn-outline btn-sm" onclick="phaseStep(1)">Next &rarr;</button>
      <button class="btn btn-outline btn-sm" onclick="phaseReset()">Reset</button>
    </div>
    <div class="slider-group">
      <label>Speed</label>
      <input type="range" id="phase-speed" min="1" max="10" value="5">
      <span class="slider-val" id="phase-speed-val">5</span>
    </div>
    <div class="stat-grid">
      <div class="stat-box stat-purple"><div class="stat-val" id="phase-name">Interphase</div><div class="stat-label">Current Phase</div></div>
      <div class="stat-box stat-blue"><div class="stat-val" id="phase-chromo">4</div><div class="stat-label">Chromosomes</div></div>
      <div class="stat-box stat-green"><div class="stat-val" id="phase-ploidy">2n</div><div class="stat-label">Ploidy</div></div>
      <div class="stat-box stat-accent"><div class="stat-val" id="phase-step">1/6</div><div class="stat-label">Step</div></div>
    </div>
    <div id="phase-description" class="analysis-result" style="border-left-color: var(--purple);">
      <div class="ar-title">Interphase</div>
      <p>The cell grows and DNA replicates (S phase). Each chromosome is duplicated into two sister chromatids joined at the centromere. The nuclear envelope is intact and chromosomes are not visible as distinct structures.</p>
    </div>
  </div>
</div>

<!-- ═══════════════════════ PART 2: VIRTUAL MICROSCOPE ═════════════════ -->
<div class="section" id="part2">
  <div class="section-header">
    <div class="section-num">2</div>
    <div><div class="section-title">Virtual Microscope &mdash; Onion Root Tip</div>
    <div class="section-subtitle">Click cells to classify their mitotic phase and calculate the mitotic index</div></div>
  </div>
  <div class="card">
    <div class="card-title">Field of View</div>
    <p style="font-size:13px;color:var(--text-muted);margin-bottom:8px;">Click on a cell, then select its phase below. Color-coded after classification.</p>
    <div class="chart-wrap"><canvas id="micro-canvas" height="420" style="cursor:crosshair;"></canvas></div>
    <div class="toggle-group" id="micro-phase-btns">
      <button class="phase-btn" onclick="microSetPhase('interphase')" style="border-color:#6366f1;color:#6366f1;">Interphase</button>
      <button class="phase-btn" onclick="microSetPhase('prophase')" style="border-color:#dc2626;color:#dc2626;">Prophase</button>
      <button class="phase-btn" onclick="microSetPhase('metaphase')" style="border-color:#ea580c;color:#ea580c;">Metaphase</button>
      <button class="phase-btn" onclick="microSetPhase('anaphase')" style="border-color:#16a34a;color:#16a34a;">Anaphase</button>
      <button class="phase-btn" onclick="microSetPhase('telophase')" style="border-color:#2563eb;color:#2563eb;">Telophase</button>
    </div>
    <div class="btn-group">
      <button class="btn btn-secondary btn-sm" onclick="microAutoClassify()">Auto-Classify All</button>
      <button class="btn btn-outline btn-sm" onclick="microReset()">New Slide</button>
    </div>
    <div class="stat-grid">
      <div class="stat-box" style="border-left:3px solid #6366f1;"><div class="stat-val" id="micro-inter">0</div><div class="stat-label">Interphase</div></div>
      <div class="stat-box" style="border-left:3px solid #dc2626;"><div class="stat-val" id="micro-pro">0</div><div class="stat-label">Prophase</div></div>
      <div class="stat-box" style="border-left:3px solid #ea580c;"><div class="stat-val" id="micro-meta">0</div><div class="stat-label">Metaphase</div></div>
      <div class="stat-box" style="border-left:3px solid #16a34a;"><div class="stat-val" id="micro-ana">0</div><div class="stat-label">Anaphase</div></div>
      <div class="stat-box" style="border-left:3px solid #2563eb;"><div class="stat-val" id="micro-telo">0</div><div class="stat-label">Telophase</div></div>
    </div>
    <div class="stat-grid">
      <div class="stat-box stat-accent"><div class="stat-val" id="micro-classified">0/40</div><div class="stat-label">Classified</div></div>
      <div class="stat-box stat-green"><div class="stat-val" id="micro-correct">-</div><div class="stat-label">Accuracy</div></div>
      <div class="stat-box stat-blue"><div class="stat-val" id="micro-mi">-</div><div class="stat-label">Mitotic Index</div></div>
    </div>
  </div>
  <div class="card-row">
    <div class="card">
      <div class="card-title">Phase Distribution</div>
      <div class="chart-wrap"><canvas id="micro-bar-chart" height="260"></canvas></div>
    </div>
    <div class="card">
      <div class="card-title">Time in Phase (estimated)</div>
      <p style="font-size:12px;color:var(--text-muted);margin-bottom:8px;">Cell cycle ~24h. Time proportional to frequency.</p>
      <div class="chart-wrap"><canvas id="micro-time-chart" height="260"></canvas></div>
    </div>
  </div>
</div>

<!-- ═══════════════════════ PART 3: CELL CYCLE CLOCK ══════════════════ -->
<div class="section" id="part3">
  <div class="section-header">
    <div class="section-num">3</div>
    <div><div class="section-title">Cell Cycle Clock</div>
    <div class="section-subtitle">Visualize the timing of each cell cycle phase in a human cell (~24 hours)</div></div>
  </div>
  <div class="card-row">
    <div class="card">
      <div class="card-title">Cycle Diagram</div>
      <div class="chart-wrap"><canvas id="clock-canvas" height="360"></canvas></div>
      <div class="toggle-group" id="clock-phase-btns">
        <button class="phase-btn active" onclick="clockSelect('G1')" id="clock-btn-G1" style="border-color:#6366f1;">G1 Phase</button>
        <button class="phase-btn" onclick="clockSelect('S')" id="clock-btn-S" style="border-color:#2563eb;">S Phase</button>
        <button class="phase-btn" onclick="clockSelect('G2')" id="clock-btn-G2" style="border-color:#16a34a;">G2 Phase</button>
        <button class="phase-btn" onclick="clockSelect('M')" id="clock-btn-M" style="border-color:#dc2626;">M Phase</button>
      </div>
    </div>
    <div class="card">
      <div class="card-title">Phase Details</div>
      <div id="clock-details" class="analysis-result" style="border-left-color:#6366f1;">
        <div class="ar-title">G1 Phase &mdash; Gap 1 (~11 hours)</div>
        <p>The cell grows, produces proteins, and carries out normal functions. The cell monitors its environment and decides whether to commit to division at the <strong>Restriction Point</strong>. If conditions are unfavorable, the cell exits to G0 (quiescence).</p>
      </div>
      <div class="stat-grid">
        <div class="stat-box stat-purple"><div class="stat-val" id="clock-duration">11 hr</div><div class="stat-label">Duration</div></div>
        <div class="stat-box stat-blue"><div class="stat-val" id="clock-pct">46%</div><div class="stat-label">% of Cycle</div></div>
      </div>
      <div class="card-title" style="margin-top:16px;">Tissue Comparison &mdash; Cell Cycle Duration</div>
      <p style="font-size:12px;color:var(--text-muted);margin-bottom:8px;">Different human tissues divide at very different rates.</p>
      <div class="chart-wrap"><canvas id="tissue-chart" height="220"></canvas></div>
    </div>
  </div>
</div>

<!-- ═══════════════════════ PART 4: CANCER & CELL CYCLE CONTROL ═══════ -->
<div class="section" id="part4">
  <div class="section-header">
    <div class="section-num">4</div>
    <div><div class="section-title">Cancer &amp; Cell Cycle Control</div>
    <div class="section-subtitle">See how mutations in checkpoints lead to uncontrolled division</div></div>
  </div>
  <div class="card">
    <div class="card-title">Cell Cycle Checkpoints</div>
    <div class="chart-wrap"><canvas id="checkpoint-canvas" height="300"></canvas></div>
    <div class="toggle-group">
      <button class="toggle-btn active" id="cc-normal" onclick="ccToggle('normal')">Normal Cell</button>
      <button class="toggle-btn" id="cc-p53" onclick="ccToggle('p53')">p53 Mutation</button>
      <button class="toggle-btn" id="cc-rb" onclick="ccToggle('rb')">Rb Mutation</button>
      <button class="toggle-btn" id="cc-onco" onclick="ccToggle('oncogene')">Oncogene Activation</button>
    </div>
    <div id="cc-description" class="analysis-result ar-pass">
      <div class="ar-title">Normal Cell Cycle</div>
      <p>All checkpoints are functional. The cell verifies DNA integrity at G1, confirms complete replication at G2, and ensures proper spindle attachment at M. Damaged cells are halted or directed to apoptosis.</p>
    </div>
  </div>
  <div class="card">
    <div class="card-title">Population Growth &mdash; Normal vs. Cancerous</div>
    <p style="font-size:13px;color:var(--text-muted);margin-bottom:8px;">Simulate 10 generations of cell division with functional vs. broken checkpoints.</p>
    <div class="btn-group">
      <button class="btn btn-primary" onclick="ccSimulate()">Run Simulation</button>
      <button class="btn btn-outline" onclick="ccResetSim()">Reset</button>
    </div>
    <div class="chart-wrap"><canvas id="growth-chart" height="280"></canvas></div>
    <div class="stat-grid">
      <div class="stat-box stat-green"><div class="stat-val" id="cc-normal-count">1</div><div class="stat-label">Normal Cells</div></div>
      <div class="stat-box stat-accent"><div class="stat-val" id="cc-cancer-count">1</div><div class="stat-label">Cancer Cells</div></div>
      <div class="stat-box stat-blue"><div class="stat-val" id="cc-doubling">-</div><div class="stat-label">Doubling Time (Cancer)</div></div>
    </div>
  </div>
</div>

<!-- ═══════════════════════ PART 5: WOUND HEALING ═════════════════════ -->
<div class="section" id="part5">
  <div class="section-header">
    <div class="section-num">5</div>
    <div><div class="section-title">Wound Healing Timeline</div>
    <div class="section-subtitle">Watch mitosis repair a skin wound through inflammation, migration, proliferation, and remodeling</div></div>
  </div>
  <div class="card">
    <div class="card-title">Skin Cross-Section</div>
    <div class="chart-wrap"><canvas id="wound-canvas" height="340"></canvas></div>
    <div class="btn-group">
      <button class="btn btn-primary" id="wound-heal-btn" onclick="woundHeal()">Heal Wound</button>
      <button class="btn btn-outline" onclick="woundReset()">New Wound</button>
    </div>
    <div class="stat-grid">
      <div class="stat-box stat-accent"><div class="stat-val" id="wound-phase">Injury</div><div class="stat-label">Phase</div></div>
      <div class="stat-box stat-blue"><div class="stat-val" id="wound-day">Day 0</div><div class="stat-label">Timeline</div></div>
      <div class="stat-box stat-green"><div class="stat-val" id="wound-mitotic">0%</div><div class="stat-label">Mitotic Rate</div></div>
    </div>
  </div>
  <div class="card-row">
    <div class="card">
      <div class="card-title">Mitotic Rate Over Time</div>
      <div class="chart-wrap"><canvas id="wound-rate-chart" height="240"></canvas></div>
    </div>
    <div class="card">
      <div class="card-title">Tissue Healing Speed Comparison</div>
      <p style="font-size:12px;color:var(--text-muted);margin-bottom:8px;">How quickly different tissues regenerate through mitosis.</p>
      <div class="chart-wrap"><canvas id="heal-compare-chart" height="240"></canvas></div>
    </div>
  </div>
</div>

<!-- ═══════════════════════ PART 6: CHROMOSOME COUNTING ═══════════════ -->
<div class="section" id="part6">
  <div class="section-header">
    <div class="section-num">6</div>
    <div><div class="section-title">Chromosome Counting Challenge</div>
    <div class="section-subtitle">Identify the mitotic stage and count chromosomes in human cells (2n=46, simplified to 2n=4)</div></div>
  </div>
  <div class="card">
    <div class="card-title">Identify &amp; Count</div>
    <div class="chart-wrap"><canvas id="chromo-canvas" height="320"></canvas></div>
    <p style="font-size:13px;color:var(--text-muted);margin:8px 0;">What phase is this cell in? How many chromosomes are visible?</p>
    <div class="toggle-group" id="chromo-phase-select">
      <button class="phase-btn" onclick="chromoGuessPhase('interphase')">Interphase</button>
      <button class="phase-btn" onclick="chromoGuessPhase('prophase')">Prophase</button>
      <button class="phase-btn" onclick="chromoGuessPhase('metaphase')">Metaphase</button>
      <button class="phase-btn" onclick="chromoGuessPhase('anaphase')">Anaphase</button>
      <button class="phase-btn" onclick="chromoGuessPhase('telophase')">Telophase</button>
    </div>
    <div class="slider-group">
      <label>Chromosome #</label>
      <input type="range" id="chromo-count" min="0" max="8" value="4" oninput="$('chromo-count-val').textContent=this.value">
      <span class="slider-val" id="chromo-count-val">4</span>
    </div>
    <div class="btn-group">
      <button class="btn btn-primary" onclick="chromoSubmit()">Submit Answer</button>
      <button class="btn btn-secondary" onclick="chromoNext()">New Cell</button>
    </div>
    <div id="chromo-feedback" class="analysis-result" style="display:none;"></div>
    <div class="stat-grid">
      <div class="stat-box stat-green"><div class="stat-val" id="chromo-score">0</div><div class="stat-label">Correct</div></div>
      <div class="stat-box stat-accent"><div class="stat-val" id="chromo-attempts">0</div><div class="stat-label">Attempts</div></div>
      <div class="stat-box stat-blue"><div class="stat-val" id="chromo-pct">-</div><div class="stat-label">Accuracy</div></div>
    </div>
  </div>
</div>

</div><!-- /main -->
</div><!-- /layout -->

<!-- ═══════════════════════════════════════════════════════════════════════
     JAVASCRIPT ENGINE
     ═══════════════════════════════════════════════════════════════════════ -->
<script>
// ── Utility ──────────────────────────────────────────────────────────────
const $ = id => document.getElementById(id);
const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const lerp = (a, b, t) => a + (b - a) * t;

// ── Chart helpers (from reference) ──────────────────────────────────────
function getCtx(id) {
  const c = $(id); const dpr = window.devicePixelRatio || 1;
  const w = c.offsetWidth || c.width || 300;
  const h = c.offsetHeight || c.height || 150;
  c.width = w * dpr; c.height = h * dpr;
  const ctx = c.getContext('2d'); ctx.scale(dpr, dpr);
  ctx.W = w; ctx.H = h;
  return ctx;
}

function drawBarChart(ctx, opts = {}) {
  const { labels, values, expected, colors, maxVal, yLabel } = opts;
  const W = ctx.W, H = ctx.H;
  const pad = { top: 20, right: 20, bottom: 40, left: 50 };
  const plotW = W - pad.left - pad.right, plotH = H - pad.top - pad.bottom;
  const n = values.length, barW = plotW / n * 0.6, gap = plotW / n * 0.4;

  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, W, H);

  const mv = maxVal || Math.max(...values, ...(expected||[0])) * 1.2 || 10;
  ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = pad.top + plotH * (1 - i/4);
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(W - pad.right, y); ctx.stroke();
    ctx.fillStyle = '#9ca3af'; ctx.font = '11px system-ui';
    ctx.textAlign = 'right'; ctx.fillText((mv * i/4).toFixed(mv > 10 ? 0 : 2), pad.left - 6, y + 4);
  }

  values.forEach((v, i) => {
    const x = pad.left + (plotW / n) * i + gap/2;
    const h = (v / mv) * plotH;
    ctx.fillStyle = colors ? colors[i] : '#c41e3a';
    ctx.beginPath();
    const r = 4;
    ctx.moveTo(x, pad.top + plotH);
    ctx.lineTo(x, pad.top + plotH - h + r);
    ctx.quadraticCurveTo(x, pad.top + plotH - h, x + r, pad.top + plotH - h);
    ctx.lineTo(x + barW - r, pad.top + plotH - h);
    ctx.quadraticCurveTo(x + barW, pad.top + plotH - h, x + barW, pad.top + plotH - h + r);
    ctx.lineTo(x + barW, pad.top + plotH);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle = '#374151'; ctx.font = 'bold 12px system-ui'; ctx.textAlign = 'center';
    ctx.fillText(labels[i], x + barW/2, H - pad.bottom + 16);
    if (v > 0) {
      ctx.fillStyle = '#1a1a1a'; ctx.font = 'bold 12px system-ui';
      ctx.fillText(v.toFixed(v % 1 ? 2 : 0), x + barW/2, pad.top + plotH - h - 6);
    }
  });

  if (expected) {
    expected.forEach((ev, i) => {
      const x = pad.left + (plotW / n) * i + gap/2;
      const y = pad.top + plotH - (ev / mv) * plotH;
      ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2; ctx.setLineDash([4,3]);
      ctx.beginPath(); ctx.moveTo(x - 4, y); ctx.lineTo(x + barW + 4, y); ctx.stroke();
      ctx.setLineDash([]);
    });
  }
}

function drawLineChart(ctx, series, opts = {}) {
  const W = ctx.W, H = ctx.H;
  const pad = { top: 20, right: 20, bottom: 30, left: 50 };
  const plotW = W - pad.left - pad.right, plotH = H - pad.top - pad.bottom;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, W, H);

  const { yMin = 0, yMax = 1, refLine, xLabel } = opts;
  const yRange = yMax - yMin;
  ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = pad.top + plotH * (1 - i/4);
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(W - pad.right, y); ctx.stroke();
    ctx.fillStyle = '#9ca3af'; ctx.font = '11px system-ui'; ctx.textAlign = 'right';
    ctx.fillText((yMin + yRange * i/4).toFixed(2), pad.left - 6, y + 4);
  }
  if (refLine !== undefined) {
    const ry = pad.top + plotH * (1 - (refLine - yMin) / yRange);
    ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 1; ctx.setLineDash([6,4]);
    ctx.beginPath(); ctx.moveTo(pad.left, ry); ctx.lineTo(W - pad.right, ry); ctx.stroke();
    ctx.setLineDash([]);
  }

  series.forEach(s => {
    if (!s.data.length) return;
    const xMax = opts.xMax || s.data.length;
    ctx.strokeStyle = s.color; ctx.lineWidth = s.width || 2;
    ctx.beginPath();
    s.data.forEach((v, i) => {
      const x = pad.left + (i / Math.max(xMax - 1, 1)) * plotW;
      const y = pad.top + plotH * (1 - (v - yMin) / yRange);
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    if (s.width !== 0) ctx.stroke();
    if (s.dots && s.data.length < 80) {
      s.data.forEach((v, i) => {
        const x = pad.left + (i / Math.max(xMax - 1, 1)) * plotW;
        const y = pad.top + plotH * (1 - (v - yMin) / yRange);
        ctx.fillStyle = s.color; ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill();
      });
    }
  });
}

// ══════════════════════════════════════════════════════════════════════════
// SIDEBAR SCROLL SPY
// ══════════════════════════════════════════════════════════════════════════
const navLinks = document.querySelectorAll('.sidebar-nav a');
window.addEventListener('scroll', () => {
  let current = '';
  document.querySelectorAll('.section, .hero').forEach(s => {
    if (window.scrollY >= s.offsetTop - 100) current = s.id;
  });
  navLinks.forEach(a => {
    a.classList.remove('active');
    if (a.getAttribute('href') === '#' + current) a.classList.add('active');
  });
});

// ══════════════════════════════════════════════════════════════════════════
// PART 1: MITOSIS PHASE ANIMATOR
// ══════════════════════════════════════════════════════════════════════════
const PHASES = [
  { name: 'Interphase', chromo: '4 (replicated)', ploidy: '2n', step: '1/6',
    desc: '<div class="ar-title">Interphase (G1 + S + G2)</div><p>The cell grows and DNA replicates during S phase. Each chromosome is duplicated into two sister chromatids joined at the centromere. The nuclear envelope is intact and chromosomes appear as diffuse chromatin.</p>' },
  { name: 'Prophase', chromo: '4 (condensed)', ploidy: '2n', step: '2/6',
    desc: '<div class="ar-title">Prophase</div><p>Chromosomes condense and become visible as distinct structures. Each consists of two sister chromatids. Centrioles migrate to opposite poles and begin forming the mitotic spindle. The nuclear envelope starts to break down.</p>' },
  { name: 'Metaphase', chromo: '4', ploidy: '2n', step: '3/6',
    desc: '<div class="ar-title">Metaphase</div><p>Chromosomes align at the <strong>metaphase plate</strong> (cell equator). Spindle fibers from each pole attach to the kinetochore of each sister chromatid. This is the best stage for counting chromosomes (2n = 46 in humans).</p>' },
  { name: 'Anaphase', chromo: '8 (separating)', ploidy: '2n &rarr; 2 sets', step: '4/6',
    desc: '<div class="ar-title">Anaphase</div><p>Sister chromatids separate at the centromere and are pulled to opposite poles by shortening spindle fibers. The cell elongates. Briefly appears to have twice the chromosome number as chromatids move apart.</p>' },
  { name: 'Telophase', chromo: '4 per nucleus', ploidy: '2n each', step: '5/6',
    desc: '<div class="ar-title">Telophase</div><p>Chromosomes arrive at opposite poles and begin to decondense. Nuclear envelopes reform around each set of chromosomes. The spindle disassembles. Two distinct nuclei are now present within one cell.</p>' },
  { name: 'Cytokinesis', chromo: '4 per cell', ploidy: '2n each', step: '6/6',
    desc: '<div class="ar-title">Cytokinesis</div><p>The cytoplasm divides. In animal cells, a <strong>cleavage furrow</strong> forms as a ring of actin filaments contracts, pinching the cell in two. Two genetically identical daughter cells result, each with 2n chromosomes.</p>' }
];

let phaseIdx = 0, phaseAnim = null, phaseT = 0;
const phaseColors = { chr1: '#dc2626', chr2: '#2563eb', chr3: '#16a34a', chr4: '#d97706' };

function phaseStep(dir) {
  phaseIdx = clamp(phaseIdx + dir, 0, 5);
  phaseT = 0;
  phaseUpdateUI();
}

function phaseReset() {
  phaseIdx = 0; phaseT = 0;
  if (phaseAnim) { cancelAnimationFrame(phaseAnim); phaseAnim = null; }
  $('phase-play-btn').textContent = 'Play';
  phaseUpdateUI();
}

function phaseTogglePlay() {
  if (phaseAnim) {
    cancelAnimationFrame(phaseAnim); phaseAnim = null;
    $('phase-play-btn').textContent = 'Play';
  } else {
    $('phase-play-btn').textContent = 'Pause';
    phaseAnimate();
  }
}

function phaseAnimate() {
  const speed = parseInt($('phase-speed').value);
  $('phase-speed-val').textContent = speed;
  phaseT += speed * 0.003;
  if (phaseT >= 1) {
    phaseT = 0;
    phaseIdx++;
    if (phaseIdx > 5) { phaseIdx = 0; }
    phaseUpdateUI();
  }
  drawPhaseAnimation();
  phaseAnim = requestAnimationFrame(phaseAnimate);
}

function phaseUpdateUI() {
  const p = PHASES[phaseIdx];
  $('phase-name').textContent = p.name;
  $('phase-chromo').innerHTML = p.chromo;
  $('phase-ploidy').innerHTML = p.ploidy;
  $('phase-step').textContent = p.step;
  $('phase-description').innerHTML = p.desc;
  $('phase-description').style.borderLeftColor = ['#6366f1','#dc2626','#ea580c','#16a34a','#2563eb','#7c3aed'][phaseIdx];
  drawPhaseAnimation();
}

function drawPhaseAnimation() {
  const ctx = getCtx('phase-canvas');
  const W = ctx.W, H = ctx.H;
  const cx = W / 2, cy = H / 2;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, W, H);

  // Phase indicator bar at top
  const barY = 10, barH = 6;
  const phaseNames = ['I', 'P', 'M', 'A', 'T', 'C'];
  const pColors = ['#6366f1','#dc2626','#ea580c','#16a34a','#2563eb','#7c3aed'];
  const segW = (W - 80) / 6;
  for (let i = 0; i < 6; i++) {
    ctx.fillStyle = i === phaseIdx ? pColors[i] : '#e5e7eb';
    ctx.beginPath();
    ctx.roundRect(40 + i * segW + 2, barY, segW - 4, barH, 3);
    ctx.fill();
    ctx.fillStyle = i === phaseIdx ? pColors[i] : '#9ca3af';
    ctx.font = 'bold 10px system-ui'; ctx.textAlign = 'center';
    ctx.fillText(phaseNames[i], 40 + i * segW + segW / 2, barY + barH + 12);
  }

  const cellR = Math.min(W, H) * 0.28;
  const t = phaseT;

  switch (phaseIdx) {
    case 0: drawInterphase(ctx, cx, cy, cellR, t); break;
    case 1: drawProphase(ctx, cx, cy, cellR, t); break;
    case 2: drawMetaphase(ctx, cx, cy, cellR, t); break;
    case 3: drawAnaphase(ctx, cx, cy, cellR, t); break;
    case 4: drawTelophase(ctx, cx, cy, cellR, t); break;
    case 5: drawCytokinesis(ctx, cx, cy, cellR, t); break;
  }
}

function drawCellMembrane(ctx, cx, cy, rx, ry, color) {
  ctx.strokeStyle = color || '#374151';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
  ctx.stroke();
  ctx.fillStyle = 'rgba(254, 242, 242, 0.3)';
  ctx.fill();
}

function drawNucleus(ctx, cx, cy, r, alpha) {
  ctx.globalAlpha = alpha !== undefined ? alpha : 1;
  ctx.strokeStyle = '#6366f1';
  ctx.lineWidth = 2;
  ctx.setLineDash([4, 3]);
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = 'rgba(99, 102, 241, 0.06)';
  ctx.fill();
  ctx.globalAlpha = 1;
}

function drawChromatin(ctx, cx, cy, r) {
  // Draw diffuse chromatin as wavy lines
  const colors = ['#dc2626', '#2563eb', '#16a34a', '#d97706'];
  for (let c = 0; c < 4; c++) {
    ctx.strokeStyle = colors[c];
    ctx.lineWidth = 1.5;
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    const angle = (c / 4) * Math.PI * 2 + 0.3;
    const sr = r * 0.3;
    for (let j = 0; j < 20; j++) {
      const t2 = j / 19;
      const x = cx + Math.cos(angle + t2 * 3) * sr * (0.5 + t2);
      const y = cy + Math.sin(angle + t2 * 2.5) * sr * (0.5 + t2);
      j === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
}

function drawCondensedChromo(ctx, x, y, angle, color, duplicated) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  const len = 18, w = 4;
  if (duplicated) {
    // Sister chromatids - X shape
    ctx.fillStyle = color;
    ctx.fillRect(-w, -len, w - 1, len * 2);
    ctx.fillRect(1, -len, w - 1, len * 2);
    // Centromere
    ctx.fillStyle = '#1a1a1a';
    ctx.beginPath();
    ctx.arc(0, 0, 3, 0, Math.PI * 2);
    ctx.fill();
  } else {
    // Single chromatid - I shape
    ctx.fillStyle = color;
    ctx.fillRect(-w / 2, -len, w, len * 2);
    ctx.fillStyle = '#1a1a1a';
    ctx.beginPath();
    ctx.arc(0, 0, 2, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

function drawCentrioles(ctx, cx, cy, cellR, separation) {
  // Two pairs of centrioles
  const d = cellR * separation;
  [[-d, 0], [d, 0]].forEach(([ox, oy], idx) => {
    ctx.fillStyle = '#374151';
    ctx.beginPath();
    ctx.arc(cx + ox, cy + oy, 5, 0, Math.PI * 2);
    ctx.fill();
    // Aster fibers
    ctx.strokeStyle = 'rgba(55, 65, 81, 0.2)';
    ctx.lineWidth = 0.5;
    for (let a = 0; a < 8; a++) {
      const ang = (a / 8) * Math.PI * 2;
      ctx.beginPath();
      ctx.moveTo(cx + ox, cy + oy);
      ctx.lineTo(cx + ox + Math.cos(ang) * 20, cy + oy + Math.sin(ang) * 20);
      ctx.stroke();
    }
  });
}

function drawSpindleFibers(ctx, cx, cy, cellR, targets) {
  ctx.strokeStyle = 'rgba(55, 65, 81, 0.15)';
  ctx.lineWidth = 0.8;
  const poleL = cx - cellR * 0.85;
  const poleR = cx + cellR * 0.85;
  targets.forEach(([tx, ty]) => {
    ctx.beginPath(); ctx.moveTo(poleL, cy); ctx.lineTo(tx, ty); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(poleR, cy); ctx.lineTo(tx, ty); ctx.stroke();
  });
}

function drawInterphase(ctx, cx, cy, R, t) {
  drawCellMembrane(ctx, cx, cy, R, R * 0.85);
  drawNucleus(ctx, cx, cy, R * 0.55);
  drawChromatin(ctx, cx, cy, R * 0.55);
  // Centrioles near nucleus
  ctx.fillStyle = '#374151';
  ctx.beginPath(); ctx.arc(cx + R * 0.35, cy - R * 0.3, 4, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + R * 0.38, cy - R * 0.26, 4, 0, Math.PI * 2); ctx.fill();
  // Label
  ctx.fillStyle = '#6366f1'; ctx.font = 'bold 13px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Nuclear envelope intact', cx, cy + R + 25);
  ctx.fillText('DNA replicates (S phase)', cx, cy + R + 42);
}

function drawProphase(ctx, cx, cy, R, t) {
  drawCellMembrane(ctx, cx, cy, R, R * 0.85);
  drawNucleus(ctx, cx, cy, R * 0.55, 1 - t * 0.5); // fading envelope
  drawCentrioles(ctx, cx, cy, R, 0.3 + t * 0.5);
  // Condensed chromosomes
  const colors = ['#dc2626', '#2563eb', '#16a34a', '#d97706'];
  const positions = [
    [cx - 15, cy - 12, -0.3],
    [cx + 15, cy - 8, 0.4],
    [cx - 10, cy + 15, 0.1],
    [cx + 12, cy + 10, -0.5]
  ];
  positions.forEach(([x, y, a], i) => {
    drawCondensedChromo(ctx, x, y, a, colors[i], true);
  });
  ctx.fillStyle = '#dc2626'; ctx.font = 'bold 13px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Chromosomes condense', cx, cy + R + 25);
  ctx.fillText('Centrioles migrate to poles', cx, cy + R + 42);
}

function drawMetaphase(ctx, cx, cy, R, t) {
  drawCellMembrane(ctx, cx, cy, R, R * 0.85);
  drawCentrioles(ctx, cx, cy, R, 0.85);
  // Chromosomes lined up at metaphase plate
  const colors = ['#dc2626', '#2563eb', '#16a34a', '#d97706'];
  const targets = [];
  for (let i = 0; i < 4; i++) {
    const y = cy - 30 + i * 20;
    targets.push([cx, y]);
    drawCondensedChromo(ctx, cx, y, 0, colors[i], true);
  }
  drawSpindleFibers(ctx, cx, cy, R, targets);
  // Metaphase plate line
  ctx.strokeStyle = 'rgba(234, 88, 12, 0.4)'; ctx.lineWidth = 1; ctx.setLineDash([4, 4]);
  ctx.beginPath(); ctx.moveTo(cx, cy - R * 0.6); ctx.lineTo(cx, cy + R * 0.6); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = '#ea580c'; ctx.font = 'bold 13px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Chromosomes at metaphase plate', cx, cy + R + 25);
  ctx.fillText('Spindle fibers attached to kinetochores', cx, cy + R + 42);
}

function drawAnaphase(ctx, cx, cy, R, t) {
  const stretch = 1 + t * 0.15;
  drawCellMembrane(ctx, cx, cy, R * stretch, R * 0.85 / stretch);
  drawCentrioles(ctx, cx, cy, R, 0.9);
  const colors = ['#dc2626', '#2563eb', '#16a34a', '#d97706'];
  const sep = 15 + t * (R * 0.45);
  const targets = [];
  for (let i = 0; i < 4; i++) {
    const y = cy - 30 + i * 20;
    // Left chromatid
    drawCondensedChromo(ctx, cx - sep, y, 0, colors[i], false);
    targets.push([cx - sep, y]);
    // Right chromatid
    drawCondensedChromo(ctx, cx + sep, y, 0, colors[i], false);
    targets.push([cx + sep, y]);
  }
  drawSpindleFibers(ctx, cx, cy, R * stretch, targets);
  ctx.fillStyle = '#16a34a'; ctx.font = 'bold 13px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Sister chromatids separate', cx, cy + R + 25);
  ctx.fillText('Pulled to opposite poles', cx, cy + R + 42);
}

function drawTelophase(ctx, cx, cy, R, t) {
  const stretch = 1.15;
  drawCellMembrane(ctx, cx, cy, R * stretch, R * 0.85 / stretch);
  const sepX = R * 0.5;
  drawNucleus(ctx, cx - sepX, cy, R * 0.35, 0.3 + t * 0.7);
  drawNucleus(ctx, cx + sepX, cy, R * 0.35, 0.3 + t * 0.7);
  // Chromosomes decondensing at each pole
  const colors = ['#dc2626', '#2563eb', '#16a34a', '#d97706'];
  for (let i = 0; i < 4; i++) {
    const angle = (i / 4) * Math.PI * 2;
    const r2 = 12;
    drawCondensedChromo(ctx, cx - sepX + Math.cos(angle) * r2, cy + Math.sin(angle) * r2, angle, colors[i], false);
    drawCondensedChromo(ctx, cx + sepX + Math.cos(angle) * r2, cy + Math.sin(angle) * r2, angle, colors[i], false);
  }
  // Cleavage furrow starting
  ctx.strokeStyle = '#7c3aed'; ctx.lineWidth = 2;
  const furrow = t * R * 0.25;
  ctx.beginPath(); ctx.moveTo(cx, cy - R * 0.85 / stretch + furrow); ctx.lineTo(cx, cy - R * 0.85 / stretch); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, cy + R * 0.85 / stretch - furrow); ctx.lineTo(cx, cy + R * 0.85 / stretch); ctx.stroke();

  ctx.fillStyle = '#2563eb'; ctx.font = 'bold 13px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Nuclear envelopes reform', cx, cy + R + 25);
  ctx.fillText('Chromosomes decondense', cx, cy + R + 42);
}

function drawCytokinesis(ctx, cx, cy, R, t) {
  const sep = R * 0.3 + t * R * 0.3;
  const pinch = 1 - t * 0.9;
  // Two daughter cells separating
  const leftCx = cx - sep, rightCx = cx + sep;
  const dR = R * 0.55;

  // Draw connecting bridge (narrowing)
  if (pinch > 0.05) {
    ctx.fillStyle = 'rgba(254, 242, 242, 0.3)';
    ctx.beginPath();
    ctx.moveTo(leftCx + dR * 0.7, cy - dR * pinch * 0.5);
    ctx.lineTo(rightCx - dR * 0.7, cy - dR * pinch * 0.5);
    ctx.lineTo(rightCx - dR * 0.7, cy + dR * pinch * 0.5);
    ctx.lineTo(leftCx + dR * 0.7, cy + dR * pinch * 0.5);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = '#374151'; ctx.lineWidth = 2; ctx.stroke();
  }

  // Left daughter cell
  drawCellMembrane(ctx, leftCx, cy, dR, dR * 0.85);
  drawNucleus(ctx, leftCx, cy, dR * 0.5);
  // Right daughter cell
  drawCellMembrane(ctx, rightCx, cy, dR, dR * 0.85);
  drawNucleus(ctx, rightCx, cy, dR * 0.5);

  // Chromatin in each
  const colors = ['#dc2626', '#2563eb', '#16a34a', '#d97706'];
  for (let i = 0; i < 4; i++) {
    const angle = (i / 4) * Math.PI * 2;
    const r2 = dR * 0.2;
    ctx.globalAlpha = 0.4;
    ctx.fillStyle = colors[i];
    ctx.beginPath(); ctx.arc(leftCx + Math.cos(angle) * r2, cy + Math.sin(angle) * r2, 3, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(rightCx + Math.cos(angle) * r2, cy + Math.sin(angle) * r2, 3, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Cleavage furrow label
  if (pinch > 0.05) {
    ctx.fillStyle = '#7c3aed'; ctx.font = '11px system-ui'; ctx.textAlign = 'center';
    ctx.fillText('Cleavage furrow', cx, cy - dR - 10);
    // Arrow pointing to furrow
    ctx.strokeStyle = '#7c3aed'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(cx, cy - dR + 5); ctx.lineTo(cx, cy - dR * pinch * 0.6); ctx.stroke();
  }

  ctx.fillStyle = '#7c3aed'; ctx.font = 'bold 13px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Cleavage furrow divides cytoplasm', cx, cy + R + 25);
  ctx.fillText('Two identical daughter cells (2n = 4)', cx, cy + R + 42);
}

// ══════════════════════════════════════════════════════════════════════════
// PART 2: VIRTUAL MICROSCOPE
// ══════════════════════════════════════════════════════════════════════════
const MICRO_PHASES = ['interphase', 'prophase', 'metaphase', 'anaphase', 'telophase'];
const MICRO_COLORS = { interphase: '#6366f1', prophase: '#dc2626', metaphase: '#ea580c', anaphase: '#16a34a', telophase: '#2563eb' };
const MICRO_EXPECTED = { interphase: 0.65, prophase: 0.15, metaphase: 0.08, anaphase: 0.06, telophase: 0.06 };

let microCells = [];
let microSelected = -1;
let microCurrentPhase = 'interphase';

function microGenerate() {
  microCells = [];
  const canvas = $('micro-canvas');
  const W = canvas.offsetWidth || 600;
  const H = 420;
  // Generate ~40 cells in a packed layout
  const cellR = 22;
  const attempts = 2000;
  let placed = 0;
  for (let a = 0; a < attempts && placed < 40; a++) {
    const x = cellR + 10 + Math.random() * (W - 2 * cellR - 20);
    const y = cellR + 10 + Math.random() * (H - 2 * cellR - 20);
    // Check overlap
    let overlap = false;
    for (const c of microCells) {
      const dx = c.x - x, dy = c.y - y;
      if (Math.sqrt(dx * dx + dy * dy) < cellR * 2.1) { overlap = true; break; }
    }
    if (overlap) continue;
    // Assign true phase based on expected distribution
    const r = Math.random();
    let phase;
    if (r < 0.65) phase = 'interphase';
    else if (r < 0.80) phase = 'prophase';
    else if (r < 0.88) phase = 'metaphase';
    else if (r < 0.94) phase = 'anaphase';
    else phase = 'telophase';

    microCells.push({
      x, y, r: cellR + rand(-3, 3),
      truePhase: phase,
      userPhase: null,
      angle: Math.random() * Math.PI * 2
    });
    placed++;
  }
  microSelected = -1;
  microDraw();
  microUpdateStats();
}

function microDraw() {
  const ctx = getCtx('micro-canvas');
  const W = ctx.W, H = ctx.H;
  ctx.clearRect(0, 0, W, H);
  // Background - slide appearance
  ctx.fillStyle = '#fefef6'; ctx.fillRect(0, 0, W, H);
  // Light grid pattern for slide texture
  ctx.strokeStyle = 'rgba(0,0,0,0.03)'; ctx.lineWidth = 0.5;
  for (let x = 0; x < W; x += 15) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
  for (let y = 0; y < H; y += 15) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }

  microCells.forEach((cell, idx) => {
    const isSelected = idx === microSelected;
    const baseColor = cell.userPhase ? MICRO_COLORS[cell.userPhase] : '#9ca3af';

    // Cell wall
    ctx.strokeStyle = isSelected ? '#1a1a1a' : 'rgba(0,0,0,0.3)';
    ctx.lineWidth = isSelected ? 3 : 1.5;
    ctx.beginPath();
    ctx.ellipse(cell.x, cell.y, cell.r, cell.r * 0.9, cell.angle * 0.2, 0, Math.PI * 2);
    ctx.stroke();

    // Cell fill
    if (cell.userPhase) {
      ctx.fillStyle = baseColor + '18';
    } else {
      ctx.fillStyle = 'rgba(250, 245, 230, 0.5)';
    }
    ctx.fill();

    // Draw phase-specific internal structure
    drawMicroCellInternals(ctx, cell);

    // Selection ring
    if (isSelected) {
      ctx.strokeStyle = '#c41e3a';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 3]);
      ctx.beginPath();
      ctx.arc(cell.x, cell.y, cell.r + 5, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  });

  // Instructions overlay if nothing classified
  const classified = microCells.filter(c => c.userPhase).length;
  if (classified === 0) {
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.font = 'bold 14px system-ui'; ctx.textAlign = 'center';
    ctx.fillText('Click a cell to select it, then choose its phase', W / 2, H - 15);
  }
}

function drawMicroCellInternals(ctx, cell) {
  const { x, y, r, truePhase, angle } = cell;
  const nucR = r * 0.5;
  ctx.globalAlpha = 0.7;

  switch (truePhase) {
    case 'interphase':
      // Clear nucleus with nucleolus
      ctx.strokeStyle = '#6366f1'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(x, y, nucR, 0, Math.PI * 2); ctx.stroke();
      ctx.fillStyle = '#4338ca'; ctx.beginPath(); ctx.arc(x + 3, y - 2, 3, 0, Math.PI * 2); ctx.fill();
      break;
    case 'prophase':
      // Condensing chromosomes, fading nucleus
      ctx.strokeStyle = 'rgba(99,102,241,0.3)'; ctx.lineWidth = 0.8;
      ctx.beginPath(); ctx.arc(x, y, nucR, 0, Math.PI * 2); ctx.stroke();
      const pColors = ['#dc2626', '#2563eb'];
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = pColors[i % 2];
        const a2 = angle + (i / 3) * Math.PI * 2;
        ctx.fillRect(x + Math.cos(a2) * nucR * 0.4 - 2, y + Math.sin(a2) * nucR * 0.4 - 5, 3, 10);
      }
      break;
    case 'metaphase':
      // Chromosomes at center line
      ctx.strokeStyle = 'rgba(234,88,12,0.4)'; ctx.lineWidth = 0.8;
      ctx.beginPath(); ctx.moveTo(x, y - r * 0.6); ctx.lineTo(x, y + r * 0.6); ctx.stroke();
      for (let i = -2; i <= 2; i++) {
        ctx.fillStyle = '#ea580c';
        ctx.fillRect(x - 2, y + i * 5 - 2, 4, 4);
      }
      break;
    case 'anaphase':
      // Chromosomes moving apart
      const sep2 = r * 0.35;
      ctx.fillStyle = '#16a34a';
      for (let i = 0; i < 3; i++) {
        ctx.fillRect(x - sep2 - 1, y - 6 + i * 6, 3, 4);
        ctx.fillRect(x + sep2 - 1, y - 6 + i * 6, 3, 4);
      }
      // Spindle suggestion
      ctx.strokeStyle = 'rgba(22,163,74,0.2)'; ctx.lineWidth = 0.5;
      ctx.beginPath(); ctx.moveTo(x - sep2, y); ctx.lineTo(x + sep2, y); ctx.stroke();
      break;
    case 'telophase':
      // Two nuclei reforming
      const tSep = r * 0.3;
      ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 0.8;
      ctx.beginPath(); ctx.arc(x - tSep, y, nucR * 0.6, 0, Math.PI * 2); ctx.stroke();
      ctx.beginPath(); ctx.arc(x + tSep, y, nucR * 0.6, 0, Math.PI * 2); ctx.stroke();
      // Furrow
      ctx.strokeStyle = 'rgba(37,99,235,0.4)'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(x, y - r * 0.4); ctx.lineTo(x, y + r * 0.4); ctx.stroke();
      break;
  }
  ctx.globalAlpha = 1;
}

$('micro-canvas').addEventListener('click', function(e) {
  const rect = this.getBoundingClientRect();
  const scaleX = (this.offsetWidth || 600) / rect.width;
  const scaleY = 420 / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;

  let closest = -1, closestD = Infinity;
  microCells.forEach((c, i) => {
    const d = Math.sqrt((c.x - mx) ** 2 + (c.y - my) ** 2);
    if (d < c.r + 5 && d < closestD) { closest = i; closestD = d; }
  });

  if (closest >= 0) {
    microSelected = closest;
    microDraw();
  }
});

function microSetPhase(phase) {
  microCurrentPhase = phase;
  if (microSelected >= 0) {
    microCells[microSelected].userPhase = phase;
    microSelected = -1;
    microDraw();
    microUpdateStats();
  }
}

function microAutoClassify() {
  microCells.forEach(c => { c.userPhase = c.truePhase; });
  microSelected = -1;
  microDraw();
  microUpdateStats();
}

function microReset() {
  microGenerate();
}

function microUpdateStats() {
  const counts = { interphase: 0, prophase: 0, metaphase: 0, anaphase: 0, telophase: 0 };
  let classified = 0, correct = 0;
  microCells.forEach(c => {
    if (c.userPhase) {
      counts[c.userPhase]++;
      classified++;
      if (c.userPhase === c.truePhase) correct++;
    }
  });

  $('micro-inter').textContent = counts.interphase;
  $('micro-pro').textContent = counts.prophase;
  $('micro-meta').textContent = counts.metaphase;
  $('micro-ana').textContent = counts.anaphase;
  $('micro-telo').textContent = counts.telophase;
  $('micro-classified').textContent = classified + '/' + microCells.length;
  $('micro-correct').textContent = classified > 0 ? (correct / classified * 100).toFixed(0) + '%' : '-';

  const dividing = counts.prophase + counts.metaphase + counts.anaphase + counts.telophase;
  const total = classified;
  $('micro-mi').textContent = total > 0 ? (dividing / total * 100).toFixed(1) + '%' : '-';

  drawMicroBarChart(counts, classified);
  drawMicroTimeChart(counts, classified);
}

function drawMicroBarChart(counts, total) {
  const ctx = getCtx('micro-bar-chart');
  const labels = ['Inter', 'Pro', 'Meta', 'Ana', 'Telo'];
  const values = [counts.interphase, counts.prophase, counts.metaphase, counts.anaphase, counts.telophase];
  const expected = total > 0 ? [total * 0.65, total * 0.15, total * 0.08, total * 0.06, total * 0.06] : null;
  const colors = ['#6366f1', '#dc2626', '#ea580c', '#16a34a', '#2563eb'];
  drawBarChart(ctx, { labels, values, expected, colors, maxVal: Math.max(...values, total * 0.7 || 10) * 1.2 });
}

function drawMicroTimeChart(counts, total) {
  const ctx = getCtx('micro-time-chart');
  if (total === 0) {
    ctx.clearRect(0, 0, ctx.W, ctx.H);
    ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, ctx.W, ctx.H);
    ctx.fillStyle = '#9ca3af'; ctx.font = '13px system-ui'; ctx.textAlign = 'center';
    ctx.fillText('Classify cells to estimate phase durations', ctx.W / 2, ctx.H / 2);
    return;
  }
  const labels = ['Inter', 'Pro', 'Meta', 'Ana', 'Telo'];
  const totalCycle = 24; // hours
  const values = [
    (counts.interphase / total) * totalCycle,
    (counts.prophase / total) * totalCycle,
    (counts.metaphase / total) * totalCycle,
    (counts.anaphase / total) * totalCycle,
    (counts.telophase / total) * totalCycle
  ];
  const colors = ['#6366f1', '#dc2626', '#ea580c', '#16a34a', '#2563eb'];
  drawBarChart(ctx, { labels, values, colors, maxVal: 26 });
}

// ══════════════════════════════════════════════════════════════════════════
// PART 3: CELL CYCLE CLOCK
// ══════════════════════════════════════════════════════════════════════════
const CLOCK_PHASES = {
  G1: { label: 'G1 Phase', dur: 11, color: '#6366f1', desc: '<div class="ar-title">G1 Phase &mdash; Gap 1 (~11 hours)</div><p>The cell grows, produces proteins, and carries out normal functions. The cell monitors its environment and decides whether to commit to division at the <strong>Restriction Point</strong>. If conditions are unfavorable, the cell exits to G0 (quiescence).</p>' },
  S:  { label: 'S Phase', dur: 8, color: '#2563eb', desc: '<div class="ar-title">S Phase &mdash; DNA Synthesis (~8 hours)</div><p>Each chromosome is replicated, producing two sister chromatids joined at the centromere. DNA content doubles from 2C to 4C. Histones are also synthesized. Errors in replication are corrected by proofreading enzymes.</p>' },
  G2: { label: 'G2 Phase', dur: 4, color: '#16a34a', desc: '<div class="ar-title">G2 Phase &mdash; Gap 2 (~4 hours)</div><p>The cell continues to grow and prepares for mitosis. Proteins needed for cell division are synthesized, including tubulin for the mitotic spindle. The cell checks that DNA replication is complete and undamaged.</p>' },
  M:  { label: 'M Phase', dur: 1, color: '#dc2626', desc: '<div class="ar-title">M Phase &mdash; Mitosis (~1 hour)</div><p>The nucleus divides (mitosis) followed by cytoplasmic division (cytokinesis). This is the shortest phase. Includes prophase, metaphase, anaphase, and telophase. The cell is most vulnerable to errors during this critical phase.</p>' }
};
let clockSelected = 'G1';

function clockSelect(phase) {
  clockSelected = phase;
  document.querySelectorAll('#clock-phase-btns .phase-btn').forEach(b => b.classList.remove('active'));
  $('clock-btn-' + phase).classList.add('active');
  const p = CLOCK_PHASES[phase];
  $('clock-details').innerHTML = p.desc;
  $('clock-details').style.borderLeftColor = p.color;
  $('clock-duration').textContent = p.dur + ' hr';
  $('clock-pct').textContent = (p.dur / 24 * 100).toFixed(0) + '%';
  drawClock();
}

function drawClock() {
  const ctx = getCtx('clock-canvas');
  const W = ctx.W, H = ctx.H;
  const cx = W / 2, cy = H / 2;
  const R = Math.min(W, H) * 0.38;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, W, H);

  const phases = ['G1', 'S', 'G2', 'M'];
  const totalH = 24;
  let startAngle = -Math.PI / 2; // 12 o'clock

  phases.forEach(key => {
    const p = CLOCK_PHASES[key];
    const sweep = (p.dur / totalH) * Math.PI * 2;
    const isSelected = key === clockSelected;

    // Arc segment
    ctx.fillStyle = isSelected ? p.color : p.color + '40';
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, isSelected ? R + 8 : R, startAngle, startAngle + sweep);
    ctx.closePath();
    ctx.fill();

    // Border
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, isSelected ? R + 8 : R, startAngle, startAngle + sweep);
    ctx.closePath();
    ctx.stroke();

    // Label
    const midAngle = startAngle + sweep / 2;
    const labelR = (isSelected ? R + 8 : R) * 0.65;
    const lx = cx + Math.cos(midAngle) * labelR;
    const ly = cy + Math.sin(midAngle) * labelR;
    ctx.fillStyle = isSelected ? '#fff' : '#374151';
    ctx.font = isSelected ? 'bold 16px system-ui' : 'bold 13px system-ui';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(key, lx, ly - 8);
    ctx.font = isSelected ? '12px system-ui' : '10px system-ui';
    ctx.fillText(p.dur + 'h', lx, ly + 8);

    startAngle += sweep;
  });

  // Center circle
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(cx, cy, R * 0.2, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#1a1a1a'; ctx.font = 'bold 14px system-ui'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText('24h', cx, cy);

  // Interphase brace
  ctx.strokeStyle = '#374151'; ctx.lineWidth = 1;
  const interStart = -Math.PI / 2;
  const interSweep = (23 / 24) * Math.PI * 2;
  ctx.beginPath();
  ctx.arc(cx, cy, R + 22, interStart, interStart + interSweep);
  ctx.stroke();
  const intMid = interStart + interSweep / 2;
  ctx.fillStyle = '#374151'; ctx.font = '11px system-ui'; ctx.textBaseline = 'middle';
  ctx.fillText('Interphase (G1 + S + G2)', cx + Math.cos(intMid) * (R + 35), cy + Math.sin(intMid) * (R + 35));
}

function drawTissueChart() {
  const ctx = getCtx('tissue-chart');
  const labels = ['Gut Epithelium', 'Skin', 'Liver', 'Bone', 'Neurons'];
  const values = [12, 24, 200, 120, 0];
  const colors = ['#dc2626', '#ea580c', '#d97706', '#2563eb', '#6b7280'];
  drawBarChart(ctx, { labels, values, colors, maxVal: 250 });
}

// ══════════════════════════════════════════════════════════════════════════
// PART 4: CANCER & CELL CYCLE CONTROL
// ══════════════════════════════════════════════════════════════════════════
let ccMode = 'normal';
let ccSimData = { normal: [1], cancer: [1] };

const CC_DESC = {
  normal: { title: 'Normal Cell Cycle', cls: 'ar-pass',
    text: 'All checkpoints are functional. The cell verifies DNA integrity at G1, confirms complete replication at G2, and ensures proper spindle attachment at M. Damaged cells are halted or directed to apoptosis (programmed cell death).' },
  p53: { title: 'p53 Tumor Suppressor Mutation', cls: 'ar-fail',
    text: 'p53 is the "guardian of the genome." When mutated, cells with DNA damage pass through the G1 checkpoint unchecked. Damaged DNA accumulates over generations, leading to genomic instability and uncontrolled proliferation. Found in >50% of all cancers.' },
  rb: { title: 'Rb Tumor Suppressor Mutation', cls: 'ar-fail',
    text: 'Retinoblastoma protein (Rb) normally blocks the G1-to-S transition until the cell receives proper growth signals. When Rb is mutated, cells bypass the restriction point and enter S phase without authorization, leading to inappropriate cell division.' },
  oncogene: { title: 'Oncogene Activation (e.g., Ras)', cls: 'ar-fail',
    text: 'Oncogenes are mutated versions of normal growth-promoting genes (proto-oncogenes). When stuck in the "ON" position, they continuously signal the cell to divide even without external growth factors. The cell cycle accelerates dramatically.' }
};

function ccToggle(mode) {
  ccMode = mode;
  document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
  $('cc-' + mode).classList.add('active');
  const d = CC_DESC[mode];
  $('cc-description').className = 'analysis-result ' + d.cls;
  $('cc-description').innerHTML = '<div class="ar-title">' + d.title + '</div><p>' + d.text + '</p>';
  drawCheckpoints();
}

function drawCheckpoints() {
  const ctx = getCtx('checkpoint-canvas');
  const W = ctx.W, H = ctx.H;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, W, H);

  const cx = W / 2, cy = H / 2;
  const R = Math.min(W, H) * 0.35;

  // Draw cell cycle as circle
  const phases = [
    { key: 'G1', angle: -Math.PI / 2, sweep: (11/24) * Math.PI * 2, color: '#6366f1' },
    { key: 'S', angle: -Math.PI / 2 + (11/24) * Math.PI * 2, sweep: (8/24) * Math.PI * 2, color: '#2563eb' },
    { key: 'G2', angle: -Math.PI / 2 + (19/24) * Math.PI * 2, sweep: (4/24) * Math.PI * 2, color: '#16a34a' },
    { key: 'M', angle: -Math.PI / 2 + (23/24) * Math.PI * 2, sweep: (1/24) * Math.PI * 2, color: '#dc2626' }
  ];

  phases.forEach(p => {
    ctx.fillStyle = p.color + '30';
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, R, p.angle, p.angle + p.sweep);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = p.color; ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(cx, cy, R, p.angle, p.angle + p.sweep);
    ctx.stroke();
    // Label
    const mid = p.angle + p.sweep / 2;
    ctx.fillStyle = p.color; ctx.font = 'bold 14px system-ui'; ctx.textAlign = 'center';
    ctx.fillText(p.key, cx + Math.cos(mid) * R * 0.7, cy + Math.sin(mid) * R * 0.7 + 5);
  });

  // Checkpoints
  const checkpoints = [
    { name: 'G1', angle: -Math.PI / 2 + (11/24) * Math.PI * 2, label: 'G1 Checkpoint\n(Restriction Point)', gene: 'p53, Rb' },
    { name: 'G2', angle: -Math.PI / 2 + (19/24) * Math.PI * 2, label: 'G2 Checkpoint\n(DNA damage?)', gene: 'p53' },
    { name: 'M', angle: -Math.PI / 2 + (23.5/24) * Math.PI * 2, label: 'M Checkpoint\n(Spindle assembly)', gene: '' }
  ];

  checkpoints.forEach(cp => {
    const cpx = cx + Math.cos(cp.angle) * R;
    const cpy = cy + Math.sin(cp.angle) * R;

    // Determine if checkpoint is functional
    let functional = true;
    if (ccMode === 'p53' && (cp.name === 'G1' || cp.name === 'G2')) functional = false;
    if (ccMode === 'rb' && cp.name === 'G1') functional = false;
    if (ccMode === 'oncogene') functional = true; // Checkpoints work but are overwhelmed

    // Gate icon
    const gateSize = 14;
    ctx.fillStyle = functional ? '#16a34a' : '#dc2626';
    ctx.strokeStyle = functional ? '#16a34a' : '#dc2626';
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.arc(cpx, cpy, gateSize, 0, Math.PI * 2); ctx.fill();

    // Check or X
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2.5;
    if (functional) {
      ctx.beginPath(); ctx.moveTo(cpx - 5, cpy); ctx.lineTo(cpx - 1, cpy + 5); ctx.lineTo(cpx + 6, cpy - 4); ctx.stroke();
    } else {
      ctx.beginPath(); ctx.moveTo(cpx - 5, cpy - 5); ctx.lineTo(cpx + 5, cpy + 5); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cpx + 5, cpy - 5); ctx.lineTo(cpx - 5, cpy + 5); ctx.stroke();
    }

    // Label
    const lblR = R + 35;
    const lx = cx + Math.cos(cp.angle) * lblR;
    const ly = cy + Math.sin(cp.angle) * lblR;
    ctx.fillStyle = functional ? '#16a34a' : '#dc2626';
    ctx.font = '10px system-ui'; ctx.textAlign = 'center';
    const lines = cp.label.split('\n');
    lines.forEach((line, i) => {
      ctx.fillText(line, lx, ly + i * 13);
    });
  });

  // Oncogene override indicator
  if (ccMode === 'oncogene') {
    ctx.fillStyle = '#dc2626'; ctx.font = 'bold 12px system-ui'; ctx.textAlign = 'center';
    ctx.fillText('Growth signals ALWAYS ON', cx, cy + R + 55);
    ctx.fillText('Cycle accelerated', cx, cy + R + 70);
    // Speed arrows around cycle
    ctx.strokeStyle = '#dc2626'; ctx.lineWidth = 2;
    for (let a = 0; a < 6; a++) {
      const ang = (a / 6) * Math.PI * 2 - Math.PI / 2;
      const ax = cx + Math.cos(ang) * (R + 18);
      const ay = cy + Math.sin(ang) * (R + 18);
      const tang = ang + Math.PI / 2;
      ctx.beginPath();
      ctx.moveTo(ax, ay);
      ctx.lineTo(ax + Math.cos(tang) * 8, ay + Math.sin(tang) * 8);
      ctx.stroke();
      // arrowhead
      ctx.beginPath();
      ctx.moveTo(ax + Math.cos(tang) * 8, ay + Math.sin(tang) * 8);
      ctx.lineTo(ax + Math.cos(tang) * 4 + Math.cos(ang) * 4, ay + Math.sin(tang) * 4 + Math.sin(ang) * 4);
      ctx.stroke();
    }
  }

  // Center label
  ctx.fillStyle = '#1a1a1a'; ctx.font = 'bold 12px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Cell', cx, cy - 6);
  ctx.fillText('Cycle', cx, cy + 8);
}

function ccSimulate() {
  ccSimData = { normal: [1], cancer: [1] };
  const generations = 10;

  for (let g = 0; g < generations; g++) {
    const prevNormal = ccSimData.normal[ccSimData.normal.length - 1];
    const prevCancer = ccSimData.cancer[ccSimData.cancer.length - 1];

    // Normal: some cells die, net ~1.8x per generation (not all divide successfully)
    let normalNew = 0;
    for (let c = 0; c < prevNormal; c++) {
      if (Math.random() < 0.7) normalNew += 2; // successful division
      else if (Math.random() < 0.5) normalNew += 1; // survived but didn't divide
      // else: apoptosis (0)
    }
    ccSimData.normal.push(Math.max(1, normalNew));

    // Cancer: faster division, less death
    let cancerNew = 0;
    const divRate = ccMode === 'oncogene' ? 0.95 : 0.9;
    for (let c = 0; c < prevCancer; c++) {
      if (Math.random() < divRate) cancerNew += 2;
      else cancerNew += 1; // cancer cells rarely die
    }
    ccSimData.cancer.push(cancerNew);
  }

  drawGrowthChart();
  $('cc-normal-count').textContent = ccSimData.normal[ccSimData.normal.length - 1];
  $('cc-cancer-count').textContent = ccSimData.cancer[ccSimData.cancer.length - 1];

  // Doubling time
  const cancerFinal = ccSimData.cancer[ccSimData.cancer.length - 1];
  const gens = ccSimData.cancer.length - 1;
  const doublingGens = gens * Math.log(2) / Math.log(cancerFinal);
  const doublingHours = doublingGens * 24;
  $('cc-doubling').textContent = doublingHours.toFixed(0) + ' hr';
}

function ccResetSim() {
  ccSimData = { normal: [1], cancer: [1] };
  drawGrowthChart();
  $('cc-normal-count').textContent = '1';
  $('cc-cancer-count').textContent = '1';
  $('cc-doubling').textContent = '-';
}

function drawGrowthChart() {
  const ctx = getCtx('growth-chart');
  const maxVal = Math.max(...ccSimData.normal, ...ccSimData.cancer);
  if (maxVal <= 1) {
    ctx.clearRect(0, 0, ctx.W, ctx.H);
    ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, ctx.W, ctx.H);
    ctx.fillStyle = '#9ca3af'; ctx.font = '13px system-ui'; ctx.textAlign = 'center';
    ctx.fillText('Run simulation to see growth curves', ctx.W / 2, ctx.H / 2);
    return;
  }
  drawLineChart(ctx, [
    { data: ccSimData.normal, color: '#16a34a', width: 2.5, dots: true },
    { data: ccSimData.cancer, color: '#dc2626', width: 2.5, dots: true }
  ], { yMin: 0, yMax: maxVal * 1.1 });
}

// ══════════════════════════════════════════════════════════════════════════
// PART 5: WOUND HEALING
// ══════════════════════════════════════════════════════════════════════════
const WOUND_PHASES = [
  { name: 'Injury', day: 0, mitotic: 0, desc: 'Fresh wound through epidermis and dermis' },
  { name: 'Inflammation', day: 1, mitotic: 5, desc: 'Blood clots form, immune cells arrive' },
  { name: 'Cell Migration', day: 3, mitotic: 20, desc: 'Epithelial cells migrate across wound bed' },
  { name: 'Proliferation', day: 5, mitotic: 85, desc: 'Mitosis peaks: new cells fill the gap' },
  { name: 'Proliferation', day: 7, mitotic: 70, desc: 'Continued cell division, new tissue forming' },
  { name: 'Remodeling', day: 10, mitotic: 30, desc: 'Collagen reorganizes, tissue strengthens' },
  { name: 'Healed', day: 14, mitotic: 8, desc: 'Epidermis restored, scar tissue matures' }
];

let woundStep = 0;
let woundAnimId = null;

function woundHeal() {
  if (woundAnimId) return;
  woundStep = 0;
  woundAnimId = setInterval(() => {
    woundStep++;
    if (woundStep >= WOUND_PHASES.length) {
      clearInterval(woundAnimId);
      woundAnimId = null;
    }
    drawWoundScene();
    woundUpdateUI();
    drawWoundRateChart();
  }, 1200);
}

function woundReset() {
  if (woundAnimId) { clearInterval(woundAnimId); woundAnimId = null; }
  woundStep = 0;
  drawWoundScene();
  woundUpdateUI();
  drawWoundRateChart();
}

function woundUpdateUI() {
  const p = WOUND_PHASES[Math.min(woundStep, WOUND_PHASES.length - 1)];
  $('wound-phase').textContent = p.name;
  $('wound-day').textContent = 'Day ' + p.day;
  $('wound-mitotic').textContent = p.mitotic + '%';
}

function drawWoundScene() {
  const ctx = getCtx('wound-canvas');
  const W = ctx.W, H = ctx.H;
  ctx.clearRect(0, 0, W, H);

  const step = Math.min(woundStep, WOUND_PHASES.length - 1);
  const progress = step / (WOUND_PHASES.length - 1);

  // Sky/background
  ctx.fillStyle = '#f0f9ff'; ctx.fillRect(0, 0, W, H);

  // Dermis layer (bottom)
  const dermisY = H * 0.65;
  ctx.fillStyle = '#fcd6bb';
  ctx.fillRect(0, dermisY, W, H - dermisY);

  // Hypodermis
  ctx.fillStyle = '#fbbf6e';
  ctx.fillRect(0, H * 0.85, W, H * 0.15);

  // Epidermis layer
  const epiY = H * 0.45;
  const epiH = dermisY - epiY;
  ctx.fillStyle = '#f9c9a3';
  ctx.fillRect(0, epiY, W, epiH);

  // Wound gap
  const woundLeft = W * 0.35;
  const woundRight = W * 0.65;
  const woundW = woundRight - woundLeft;
  const healProgress = clamp(progress, 0, 1);

  // Wound cavity (partially filled based on healing)
  const gapReduction = healProgress * woundW * 0.5;
  const currentLeft = woundLeft + gapReduction;
  const currentRight = woundRight - gapReduction;

  if (currentRight > currentLeft) {
    // Wound opening
    ctx.fillStyle = step === 0 ? '#dc2626' : (step <= 2 ? '#f87171' : '#fcd6bb');
    ctx.fillRect(currentLeft, epiY, currentRight - currentLeft, epiH);

    // Blood/clot in wound
    if (step >= 1 && step <= 3) {
      ctx.fillStyle = 'rgba(185, 28, 28, 0.3)';
      ctx.fillRect(currentLeft, epiY + epiH * 0.3, currentRight - currentLeft, epiH * 0.7);
    }

    // Migrating cells (step 2-3)
    if (step >= 2 && step <= 4) {
      ctx.fillStyle = '#16a34a';
      const cellCount = Math.min(step * 3, 8);
      for (let i = 0; i < cellCount; i++) {
        const cx2 = currentLeft + (i + 0.5) * ((currentRight - currentLeft) / cellCount);
        const cy2 = epiY + epiH * 0.5 + Math.sin(i * 1.5) * 5;
        ctx.beginPath(); ctx.arc(cx2, cy2, 4, 0, Math.PI * 2); ctx.fill();
      }
    }

    // Mitotic cells (dividing) - step 3-5
    if (step >= 3 && step <= 5) {
      const mitoticCount = step === 4 ? 6 : 3;
      ctx.fillStyle = '#7c3aed';
      for (let i = 0; i < mitoticCount; i++) {
        const mx = currentLeft + Math.random() * (currentRight - currentLeft);
        const my = epiY + Math.random() * epiH;
        // Dividing cell (figure-8)
        ctx.beginPath(); ctx.arc(mx - 3, my, 4, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(mx + 3, my, 4, 0, Math.PI * 2); ctx.fill();
      }
    }
  }

  // Scar tissue (late stages)
  if (step >= 5) {
    ctx.fillStyle = 'rgba(251, 191, 36, 0.2)';
    ctx.fillRect(woundLeft + gapReduction * 0.5, epiY, woundW - gapReduction, epiH);
  }

  // Layer labels
  ctx.fillStyle = '#374151'; ctx.font = '12px system-ui'; ctx.textAlign = 'left';
  ctx.fillText('Epidermis', 10, epiY + 18);
  ctx.fillText('Dermis', 10, dermisY + 18);
  ctx.fillText('Hypodermis', 10, H * 0.87 + 14);

  // Phase label at top
  const p = WOUND_PHASES[step];
  ctx.fillStyle = '#1a1a1a'; ctx.font = 'bold 16px system-ui'; ctx.textAlign = 'center';
  ctx.fillText(p.name + ' (Day ' + p.day + ')', W / 2, 25);
  ctx.fillStyle = '#6b7280'; ctx.font = '13px system-ui';
  ctx.fillText(p.desc, W / 2, 45);

  // Mitotic rate indicator
  const barX = W * 0.75, barY = 60, barW = W * 0.2, barH = 12;
  ctx.fillStyle = '#e5e7eb';
  ctx.fillRect(barX, barY, barW, barH);
  ctx.fillStyle = '#dc2626';
  ctx.fillRect(barX, barY, barW * (p.mitotic / 100), barH);
  ctx.fillStyle = '#374151'; ctx.font = '10px system-ui'; ctx.textAlign = 'left';
  ctx.fillText('Mitotic rate: ' + p.mitotic + '%', barX, barY - 4);
}

function drawWoundRateChart() {
  const ctx = getCtx('wound-rate-chart');
  const dataPoints = WOUND_PHASES.slice(0, Math.min(woundStep + 1, WOUND_PHASES.length));
  if (dataPoints.length < 2) {
    ctx.clearRect(0, 0, ctx.W, ctx.H);
    ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, ctx.W, ctx.H);
    ctx.fillStyle = '#9ca3af'; ctx.font = '13px system-ui'; ctx.textAlign = 'center';
    ctx.fillText('Click "Heal Wound" to see the timeline', ctx.W / 2, ctx.H / 2);
    return;
  }
  const data = dataPoints.map(p => p.mitotic / 100);
  drawLineChart(ctx, [
    { data, color: '#dc2626', width: 2.5, dots: true }
  ], { yMin: 0, yMax: 1, refLine: null, xMax: WOUND_PHASES.length });
}

function drawHealCompareChart() {
  const ctx = getCtx('heal-compare-chart');
  const labels = ['Skin', 'Liver', 'Bone', 'Muscle', 'Nerve'];
  const values = [14, 60, 90, 42, 365];
  const colors = ['#dc2626', '#d97706', '#2563eb', '#16a34a', '#6b7280'];
  drawBarChart(ctx, { labels, values, colors, maxVal: 400 });
}

// ══════════════════════════════════════════════════════════════════════════
// PART 6: CHROMOSOME COUNTING CHALLENGE
// ══════════════════════════════════════════════════════════════════════════
const CHROMO_CHALLENGES = ['interphase', 'prophase', 'metaphase', 'anaphase', 'telophase'];

let chromoCurrentPhase = '';
let chromoGuessedPhase = '';
let chromoScore = 0;
let chromoAttempts = 0;

function chromoGenerateCell() {
  chromoCurrentPhase = CHROMO_CHALLENGES[rand(0, 4)];
  chromoGuessedPhase = '';
  document.querySelectorAll('#chromo-phase-select .phase-btn').forEach(b => b.classList.remove('active'));
  $('chromo-feedback').style.display = 'none';
  drawChromoCell();
}

function chromoGuessPhase(phase) {
  chromoGuessedPhase = phase;
  document.querySelectorAll('#chromo-phase-select .phase-btn').forEach(b => b.classList.remove('active'));
  event.target.classList.add('active');
}

function chromoSubmit() {
  if (!chromoGuessedPhase || !chromoCurrentPhase) return;
  const guessCount = parseInt($('chromo-count').value);
  chromoAttempts++;

  let correctCount;
  switch (chromoCurrentPhase) {
    case 'interphase': correctCount = 0; break; // can't count - diffuse
    case 'prophase': correctCount = 4; break;
    case 'metaphase': correctCount = 4; break;
    case 'anaphase': correctCount = 8; break;
    case 'telophase': correctCount = 4; break;
  }

  const phaseCorrect = chromoGuessedPhase === chromoCurrentPhase;
  const countCorrect = guessCount === correctCount;
  const bothCorrect = phaseCorrect && countCorrect;

  if (bothCorrect) chromoScore++;

  const fb = $('chromo-feedback');
  fb.style.display = 'block';

  let explain = '';
  switch (chromoCurrentPhase) {
    case 'interphase':
      explain = 'In interphase, chromosomes are decondensed chromatin. You cannot count individual chromosomes. The cell has replicated DNA (4C content) but chromosomes are not visible as distinct structures.';
      break;
    case 'prophase':
      explain = 'In prophase, chromosomes condense and become visible. Each consists of 2 sister chromatids joined at the centromere. 2n = 4 chromosomes are visible (each appearing as an X-shape).';
      break;
    case 'metaphase':
      explain = 'Metaphase is the BEST stage for counting chromosomes. They are maximally condensed and aligned at the metaphase plate. Count = 2n = 4 chromosomes.';
      break;
    case 'anaphase':
      explain = 'In anaphase, sister chromatids have separated. It temporarily appears as if there are 8 chromosomes (4 moving to each pole), but each pole will receive 2n = 4.';
      break;
    case 'telophase':
      explain = 'In telophase, each pole has a complete set of 2n = 4 chromosomes. They are decondensing and nuclear envelopes are reforming.';
      break;
  }

  fb.className = 'analysis-result ' + (bothCorrect ? 'ar-pass' : 'ar-fail');
  fb.innerHTML = '<div class="ar-title">' + (bothCorrect ? 'Correct!' : 'Not quite') + '</div>' +
    '<p><strong>Phase:</strong> ' + chromoCurrentPhase.charAt(0).toUpperCase() + chromoCurrentPhase.slice(1) +
    ' (you said: ' + chromoGuessedPhase + ') ' + (phaseCorrect ? '&#10003;' : '&#10007;') + '</p>' +
    '<p><strong>Chromosome count:</strong> ' + correctCount + ' (you said: ' + guessCount + ') ' + (countCorrect ? '&#10003;' : '&#10007;') + '</p>' +
    '<p style="margin-top:8px;color:var(--text-muted);">' + explain + '</p>';

  $('chromo-score').textContent = chromoScore;
  $('chromo-attempts').textContent = chromoAttempts;
  $('chromo-pct').textContent = chromoAttempts > 0 ? (chromoScore / chromoAttempts * 100).toFixed(0) + '%' : '-';
}

function chromoNext() {
  chromoGenerateCell();
}

function drawChromoCell() {
  const ctx = getCtx('chromo-canvas');
  const W = ctx.W, H = ctx.H;
  const cx = W / 2, cy = H / 2;
  const R = Math.min(W, H) * 0.32;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, W, H);

  // Microscope-like vignette
  ctx.fillStyle = '#fefef6';
  ctx.beginPath(); ctx.arc(cx, cy, R + 40, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 40;
  ctx.beginPath(); ctx.arc(cx, cy, R + 60, 0, Math.PI * 2); ctx.stroke();

  // Cell membrane
  drawCellMembrane(ctx, cx, cy, R, R * 0.85);

  const chrColors = ['#dc2626', '#2563eb', '#16a34a', '#d97706'];

  switch (chromoCurrentPhase) {
    case 'interphase':
      drawNucleus(ctx, cx, cy, R * 0.6);
      // Diffuse chromatin
      for (let c = 0; c < 4; c++) {
        ctx.strokeStyle = chrColors[c]; ctx.lineWidth = 1; ctx.globalAlpha = 0.3;
        ctx.beginPath();
        for (let j = 0; j < 30; j++) {
          const t2 = j / 29;
          const a = (c / 4) * Math.PI * 2 + t2 * 5;
          const r2 = R * 0.15 + t2 * R * 0.3;
          const x = cx + Math.cos(a) * r2;
          const y = cy + Math.sin(a) * r2;
          j === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      // Nucleolus
      ctx.fillStyle = '#4338ca'; ctx.beginPath(); ctx.arc(cx + 5, cy - 3, 6, 0, Math.PI * 2); ctx.fill();
      break;

    case 'prophase':
      drawNucleus(ctx, cx, cy, R * 0.6, 0.4);
      for (let c = 0; c < 4; c++) {
        const a = (c / 4) * Math.PI * 2 + 0.5;
        const cr = R * 0.25;
        drawCondensedChromo(ctx, cx + Math.cos(a) * cr, cy + Math.sin(a) * cr, a + 0.3, chrColors[c], true);
      }
      drawCentrioles(ctx, cx, cy, R, 0.5);
      break;

    case 'metaphase':
      for (let c = 0; c < 4; c++) {
        const yOff = -24 + c * 16;
        drawCondensedChromo(ctx, cx, cy + yOff, 0, chrColors[c], true);
      }
      drawCentrioles(ctx, cx, cy, R, 0.9);
      // Metaphase plate
      ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 1; ctx.setLineDash([3, 3]);
      ctx.beginPath(); ctx.moveTo(cx, cy - R * 0.7); ctx.lineTo(cx, cy + R * 0.7); ctx.stroke();
      ctx.setLineDash([]);
      drawSpindleFibers(ctx, cx, cy, R, [[cx, cy - 24], [cx, cy - 8], [cx, cy + 8], [cx, cy + 24]]);
      break;

    case 'anaphase': {
      const sep = R * 0.5;
      for (let c = 0; c < 4; c++) {
        const yOff = -18 + c * 12;
        drawCondensedChromo(ctx, cx - sep, cy + yOff, 0, chrColors[c], false);
        drawCondensedChromo(ctx, cx + sep, cy + yOff, 0, chrColors[c], false);
      }
      drawCentrioles(ctx, cx, cy, R, 0.95);
      // Cell elongation suggestion
      const stretch = 1.15;
      ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.ellipse(cx, cy, R * stretch, R * 0.75, 0, 0, Math.PI * 2); ctx.stroke();
      break;
    }

    case 'telophase': {
      const tSep = R * 0.45;
      drawNucleus(ctx, cx - tSep, cy, R * 0.35, 0.6);
      drawNucleus(ctx, cx + tSep, cy, R * 0.35, 0.6);
      for (let c = 0; c < 4; c++) {
        const a = (c / 4) * Math.PI * 2;
        const r2 = R * 0.15;
        drawCondensedChromo(ctx, cx - tSep + Math.cos(a) * r2, cy + Math.sin(a) * r2, a, chrColors[c], false);
        drawCondensedChromo(ctx, cx + tSep + Math.cos(a) * r2, cy + Math.sin(a) * r2, a, chrColors[c], false);
      }
      // Cleavage furrow
      ctx.strokeStyle = '#7c3aed'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(cx, cy - R * 0.3); ctx.lineTo(cx, cy + R * 0.3); ctx.stroke();
      break;
    }
  }

  // Prompt
  ctx.fillStyle = '#374151'; ctx.font = 'bold 14px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Identify the phase and count the chromosomes', cx, H - 15);
}

// ══════════════════════════════════════════════════════════════════════════
// INITIALIZATION
// ══════════════════════════════════════════════════════════════════════════
function init() {
  // Part 1: Phase animator
  drawPhaseAnimation();

  // Part 2: Virtual microscope
  microGenerate();

  // Part 3: Cell cycle clock
  drawClock();
  drawTissueChart();

  // Part 4: Cancer
  drawCheckpoints();
  drawGrowthChart();

  // Part 5: Wound healing
  drawWoundScene();
  drawWoundRateChart();
  drawHealCompareChart();
  woundUpdateUI();

  // Part 6: Chromosome challenge
  chromoGenerateCell();
}

// Run init after DOM ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}

// Redraw on resize
window.addEventListener('resize', () => {
  drawPhaseAnimation();
  microDraw();
  drawClock();
  drawTissueChart();
  drawCheckpoints();
  drawGrowthChart();
  drawWoundScene();
  drawWoundRateChart();
  drawHealCompareChart();
  drawChromoCell();
  microUpdateStats();
});
</script>
</body>
</html>
